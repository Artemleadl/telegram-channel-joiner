#!/usr/bin/env python3
import os
import sys
import logging
import asyncio
import fcntl
import tempfile
import shutil
from typing import List, Optional, Dict, Tuple
from datetime import datetime, timedelta
from contextlib import contextmanager
from telethon import TelegramClient, events, Button
from telethon.sessions import StringSession
from telethon.tl.functions.channels import JoinChannelRequest, GetParticipantsRequest
from telethon.tl.functions.messages import ImportChatInviteRequest, GetMessagesRequest, SendMessageRequest, GetDialogsRequest
from telethon.tl.functions.users import GetFullUserRequest
from telethon.tl.types import ChannelParticipantsSearch, User, Channel, Message, InputPeerEmpty
from telethon.errors import (
    FloodWaitError,
    ChatWriteForbiddenError,
    ChannelInvalidError,
    ChannelPrivateError,
    AuthKeyError,
    SecurityError,
    PhoneNumberInvalidError,
    SessionPasswordNeededError,
    PhoneCodeInvalidError
)
from dotenv import load_dotenv
import csv
from docx import Document
from openpyxl import load_workbook
import time
from PIL import Image
from io import BytesIO
import pytesseract
import re
import xlrd
import textract
import PyPDF2
import striprtf.striprtf
from odf import opendocument
from odf.table import Table, TableRow, TableCell
import json

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—É—Ç–µ–π
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
LOGS_DIR = os.path.join(BASE_DIR, 'logs')
SESSIONS_DIR = os.path.join(BASE_DIR, 'sessions')
SCREENSHOTS_DIR = os.path.join(BASE_DIR, 'captcha_screenshots')
os.makedirs(LOGS_DIR, exist_ok=True)
os.makedirs(SESSIONS_DIR, exist_ok=True)
os.makedirs(SCREENSHOTS_DIR, exist_ok=True)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('telegram_bot')

class SessionManager:
    def __init__(self, session_dir: str):
        self.session_dir = session_dir
        self.locks = {}
        self.lock_files = {}

    def acquire_lock(self, session_name: str) -> bool:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è —Å–µ—Å—Å–∏–∏"""
        try:
            lock_file = os.path.join(self.session_dir, f"{session_name}.lock")
            f = open(lock_file, 'w')
            fcntl.flock(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
            self.locks[session_name] = f
            self.lock_files[session_name] = lock_file
            return True
        except IOError:
            logger.error(f"–°–µ—Å—Å–∏—è {session_name} —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è")
            return False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: {str(e)}")
            return False

    def release_lock(self, session_name: str):
        """–û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Å–µ—Å—Å–∏–∏"""
        try:
            if session_name in self.locks:
                f = self.locks.pop(session_name)
                fcntl.flock(f.fileno(), fcntl.LOCK_UN)
                f.close()
                
                lock_file = self.lock_files.pop(session_name, None)
                if lock_file and os.path.exists(lock_file):
                    try:
                        os.remove(lock_file)
                    except OSError:
                        pass
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: {str(e)}")

    def __del__(self):
        """–û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –≤—Å–µ—Ö –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ –ø—Ä–∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–∏ –æ–±—ä–µ–∫—Ç–∞"""
        for session_name in list(self.locks.keys()):
            self.release_lock(session_name)

class ResourceManager:
    @staticmethod
    @contextmanager
    def managed_file(file: BytesIO):
        """–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏"""
        try:
            yield file
        finally:
            file.close()

    @staticmethod
    def cleanup_old_files(directory: str, max_age_hours: int = 24):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤"""
        try:
            current_time = datetime.now()
            for filename in os.listdir(directory):
                filepath = os.path.join(directory, filename)
                try:
                    file_time = datetime.fromtimestamp(os.path.getctime(filepath))
                    if (current_time - file_time).total_seconds() > max_age_hours * 3600:
                        os.remove(filepath)
                        logger.info(f"–£–¥–∞–ª–µ–Ω —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª: {filepath}")
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞ {filepath}: {str(e)}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ {directory}: {str(e)}")

class UserAccount:
    def __init__(self, phone: str, api_id: int, api_hash: str, session_manager: SessionManager):
        self.phone = phone
        self.api_id = api_id
        self.api_hash = api_hash
        self.client = None
        self.session_manager = session_manager
        self.session_name = f'user_{phone}'
        self.session_file = os.path.join(SESSIONS_DIR, self.session_name)
        self.phone_code_hash = None
        self.captcha_tasks = {}
        self.join_count = 0  # –°—á–µ—Ç—á–∏–∫ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–π
        self.current_delay = 10  # –ù–∞—á–∞–ª—å–Ω–∞—è –ø–∞—É–∑–∞ 10 —Å–µ–∫—É–Ω–¥

    async def start_client(self):
        """–ó–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞"""
        try:
            if not self.session_manager.acquire_lock(self.session_name):
                return False

            logger.info("–°–æ–∑–¥–∞—é –∫–ª–∏–µ–Ω—Ç...")
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –∏–º—è —Å–µ—Å—Å–∏–∏, –±–µ–∑ –ø—É—Ç–∏
            self.client = TelegramClient(self.session_name, self.api_id, self.api_hash)
            
            logger.info("–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ Telegram...")
            await self.client.connect()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
            if await self.client.is_user_authorized():
                logger.info("–ö–ª–∏–µ–Ω—Ç —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
                return True
                
            logger.info("–û—Ç–ø—Ä–∞–≤–ª—è—é –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è...")
            result = await self.client.send_code_request(self.phone)
            self.phone_code_hash = result.phone_code_hash
            code = input("–í–≤–µ–¥–∏—Ç–µ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: ")
            try:
                await self.client.sign_in(
                    phone=self.phone,
                    code=code,
                    phone_code_hash=self.phone_code_hash
                )
            except SessionPasswordNeededError:
                while True:
                    try:
                        password = input("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏: ")
                        await self.client.sign_in(password=password)
                        break
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–≤–æ–¥–µ –ø–∞—Ä–æ–ª—è: {str(e)}")
                        retry = input("–•–æ—Ç–∏—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –≤–≤–µ—Å—Ç–∏ –ø–∞—Ä–æ–ª—å —Å–Ω–æ–≤–∞? (y/n): ")
                        if retry.lower() != 'y':
                            self.session_manager.release_lock(self.session_name)
                            return False
            
            logger.info("–£—Å–ø–µ—à–Ω–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∫–ª–∏–µ–Ω—Ç–∞: {str(e)}")
            self.session_manager.release_lock(self.session_name)
            if self.client:
                await self.client.disconnect()
            return False

    async def send_code(self):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è"""
        try:
            # –°–æ–∑–¥–∞–µ–º –∏ –ø–æ–¥–∫–ª—é—á–∞–µ–º –∫–ª–∏–µ–Ω—Ç, –µ—Å–ª–∏ –µ–≥–æ –µ—â–µ –Ω–µ—Ç
            if not self.client:
                logger.info("–°–æ–∑–¥–∞—é –∫–ª–∏–µ–Ω—Ç...")
                self.client = TelegramClient(self.session_name, self.api_id, self.api_hash)
                
            if not self.client.is_connected():
                logger.info("–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ Telegram...")
                await self.client.connect()
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –ª–∏ —É–∂–µ –∫–ª–∏–µ–Ω—Ç
            if await self.client.is_user_authorized():
                logger.warning("–ö–ª–∏–µ–Ω—Ç —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
                return True  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º True, —Ç–∞–∫ –∫–∞–∫ –∫–ª–∏–µ–Ω—Ç —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω
                
            try:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–¥
                result = await self.client.send_code_request(phone=self.phone)
                
                if not result or not hasattr(result, 'phone_code_hash'):
                    logger.error("–ù–µ –ø–æ–ª—É—á–µ–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Telegram")
                    return False
                    
                self.phone_code_hash = result.phone_code_hash
                
                # –õ–æ–≥–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–¥–µ
                code_type = result.type.__class__.__name__
                logger.info(f"–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —á–µ—Ä–µ–∑ {code_type}")
                logger.info(f"Phone code hash: {self.phone_code_hash}")
                
                return True
                
            except PhoneNumberInvalidError:
                logger.error(f"–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞: {self.phone}")
                return False
                
            except FloodWaitError as e:
                logger.error(f"–ù—É–∂–Ω–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å {e.seconds} —Å–µ–∫—É–Ω–¥")
                return False
                
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–æ–¥–∞: {str(e)}")
            if self.client:
                await self.client.disconnect()
            return False

    async def sign_in(self, code: str):
        """–í—Ö–æ–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç —Å –∫–æ–¥–æ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è"""
        try:
            if not self.client:
                logger.error("–ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
                return False
                
            if not self.client.is_connected():
                logger.info("–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ Telegram...")
                await self.client.connect()
                
            if not self.phone_code_hash:
                logger.error("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç phone_code_hash")
                return False
                
            await self.client.sign_in(
                phone=self.phone,
                code=code,
                phone_code_hash=self.phone_code_hash
            )
            logger.info("–£—Å–ø–µ—à–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è")
            return True
            
        except SessionPasswordNeededError:
            logger.error("–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–æ–ª—å –¥–≤—É—Ö—Ñ–∞–∫—Ç–æ—Ä–Ω–æ–π –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏")
            return False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ: {str(e)}")
            if "phone code expired" in str(e).lower():
                logger.info("–ö–æ–¥ –∏—Å—Ç–µ–∫, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π")
                return await self.send_code()
            return False

    async def disconnect(self):
        """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç –∞–∫–∫–∞—É–Ω—Ç–∞"""
        try:
            if self.client:
                await self.client.disconnect()
                self.client = None
                self.phone_code_hash = None
                
                # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
                self.session_manager.release_lock(self.session_name)
                
                # –ù–ï —É–¥–∞–ª—è–µ–º —Ñ–∞–π–ª —Å–µ—Å—Å–∏–∏, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
                logger.info(f"–ö–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á–µ–Ω, —Å–µ—Å—Å–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏: {str(e)}")

    async def get_account_info(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ"""
        try:
            if not self.client:
                logger.error("–ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
                return None
                
            if not self.client.is_connected():
                logger.info("–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ Telegram...")
                await self.client.connect()
                
            if not await self.client.is_user_authorized():
                logger.error("–ö–ª–∏–µ–Ω—Ç –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
                return None

            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
            me = await self.client.get_me()
            full_user = await self.client.get_entity(me.id)

            # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–∏–∞–ª–æ–≥–æ–≤ –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –∫–∞–Ω–∞–ª–æ–≤
            dialogs = await self.client.get_dialogs()
            
            # –°—á–∏—Ç–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ç–∏–ø—ã —á–∞—Ç–æ–≤
            channels = sum(1 for d in dialogs if d.is_channel)
            large_groups = sum(1 for d in dialogs if d.is_group and hasattr(d.entity, 'participants_count') and d.entity.participants_count > 200)
            small_groups = sum(1 for d in dialogs if d.is_group and hasattr(d.entity, 'participants_count') and d.entity.participants_count <= 200)
            private_chats = sum(1 for d in dialogs if d.is_user)
            
            # –°—á–∏—Ç–∞–µ–º —á–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —É—á–∏—Ç—ã–≤–∞—é—Ç—Å—è –≤ –ª–∏–º–∏—Ç–µ
            limited_chats = channels + large_groups
            max_limited_chats = 1000 if me.premium else 500

            # –§–æ—Ä–º–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
            account_info = {
                'first_name': me.first_name or "–ë–µ–∑ –∏–º–µ–Ω–∏",
                'username': me.username or "–ë–µ–∑ username",
                'phone': self.phone,
                'account_type': "Premium" if me.premium else "–û–±—ã—á–Ω—ã–π",
                'channels': channels,
                'large_groups': large_groups,
                'small_groups': small_groups,
                'private_chats': private_chats,
                'total_chats': len(dialogs),
                'limited_chats': limited_chats,
                'limits': {
                    'max_limited_chats': max_limited_chats,
                    'joins_per_day': 300 if me.premium else 200
                },
                'available_joins': max_limited_chats - limited_chats
            }

            return account_info

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ: {str(e)}")
            return None

    async def extract_chat_links(self, text: str) -> List[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Å—ã–ª–æ–∫ –Ω–∞ –∫–∞–Ω–∞–ª—ã –∏–∑ —Ç–µ–∫—Å—Ç–∞"""
        links = []
        seen_links = set()
        
        # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –æ—Ç–¥–µ–ª—å–Ω–æ
        for line in text.split('\n'):
            line = line.strip()
            if not line:
                continue
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ —Å—Å—ã–ª–∫–∏
            if 'joinchat' in line or '+' in line:
                match = re.search(r'(?:https?://)?(?:t|telegram)\.me/(?:joinchat/|\+)([a-zA-Z0-9_-]+)', line)
                if match:
                    invite_hash = match.group(1)
                    link = f"https://t.me/joinchat/{invite_hash}"
                    if link not in seen_links:
                        links.append(link)
                        seen_links.add(link)
                        logger.info(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞: {link}")
                    continue
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—É–±–ª–∏—á–Ω—ã–µ —Å—Å—ã–ª–∫–∏ –∏ —é–∑–µ—Ä–Ω–µ–π–º—ã
            if line.startswith('@'):
                username = line[1:]
            elif line.startswith(('https://', 'http://', 't.me')):
                username = re.sub(r'^(?:https?://)?(?:t\.me/)?', '', line)
            else:
                username = line
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫
            if username:
                link = f"https://t.me/{username}"
                if link not in seen_links:
                    links.append(link)
                    seen_links.add(link)
                    logger.info(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –ø—É–±–ª–∏—á–Ω–∞—è —Å—Å—ã–ª–∫–∞: {link}")
        
        return links

    async def save_captcha_screenshot(self, chat, message: Message) -> Optional[str]:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–∞–ø—á–µ–π"""
        try:
            if not message or not message.media:
                return None
                
            # –°–∫–∞—á–∏–≤–∞–µ–º –º–µ–¥–∏–∞ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
            media = await self.client.download_media(message.media, file=BytesIO())
            if not media:
                return None
                
            # –°–æ–∑–¥–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞ —Å timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"captcha_{chat.id}_{timestamp}.png"
            filepath = os.path.join(SCREENSHOTS_DIR, filename)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            if isinstance(media, BytesIO):
                image = Image.open(media)
                image.save(filepath)
                logger.info(f"–°–∫—Ä–∏–Ω—à–æ—Ç –∫–∞–ø—á–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {filepath}")
                return filepath
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞ –∫–∞–ø—á–∏: {str(e)}")
            return None

    async def process_captcha(self, chat, message: Message) -> Optional[str]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–ø—á–∏ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏"""
        try:
            if not message or not message.media:
                return None
                
            # –°–∫–∞—á–∏–≤–∞–µ–º –º–µ–¥–∏–∞ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è
            media = await self.client.download_media(message.media, file=BytesIO())
            if not media:
                return None
                
            # –°–æ–∑–¥–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞ —Å timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"captcha_{chat.id}_{timestamp}.png"
            filepath = os.path.join(SCREENSHOTS_DIR, filename)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            if isinstance(media, BytesIO):
                image = Image.open(media)
                image.save(filepath)
                
                # –†–∞—Å–ø–æ–∑–Ω–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
                text = pytesseract.image_to_string(image, lang='eng')
                logger.info(f"–†–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∫–∞–ø—á–∏: {text}")
                
                # –ò—â–µ–º –∑–∞–¥–∞–Ω–∏–µ –≤ —Ç–µ–∫—Å—Ç–µ
                task_match = re.search(r'what\s+is\s+(\d+)\s*[\+\-\*\/]\s*(\d+)', text.lower())
                if task_match:
                    num1 = int(task_match.group(1))
                    num2 = int(task_match.group(2))
                    operator = re.search(r'[\+\-\*\/]', text).group()
                    
                    # –í—ã—á–∏—Å–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    if operator == '+':
                        result = num1 + num2
                    elif operator == '-':
                        result = num1 - num2
                    elif operator == '*':
                        result = num1 * num2
                    elif operator == '/':
                        result = num1 / num2
                    else:
                        return None
                        
                    logger.info(f"–ó–∞–¥–∞–Ω–∏–µ: {num1} {operator} {num2} = {result}")
                    return str(result)
                    
                # –ò—â–µ–º –¥—Ä—É–≥–∏–µ —Ç–∏–ø—ã –∑–∞–¥–∞–Ω–∏–π
                if "type the word" in text.lower():
                    word_match = re.search(r'type\s+the\s+word\s+"([^"]+)"', text.lower())
                    if word_match:
                        word = word_match.group(1)
                        logger.info(f"–ó–∞–¥–∞–Ω–∏–µ: –Ω–∞–ø–∏—Å–∞—Ç—å —Å–ª–æ–≤–æ '{word}'")
                        return word
                        
                if "click the button" in text.lower():
                    button_match = re.search(r'click\s+the\s+button\s+with\s+the\s+word\s+"([^"]+)"', text.lower())
                    if button_match:
                        word = button_match.group(1)
                        logger.info(f"–ó–∞–¥–∞–Ω–∏–µ: –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É —Å–æ —Å–ª–æ–≤–æ–º '{word}'")
                        return word
                        
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–∞–ø—á–∏: {str(e)}")
            return None

    async def solve_captcha(self, chat, message: Message) -> bool:
        """–†–µ—à–µ–Ω–∏–µ –∫–∞–ø—á–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞"""
        try:
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–ø—á—É
            answer = await self.process_captcha(chat, message)
            if not answer:
                logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ –∫–∞–ø—á–∏")
                return False
                
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
            await self.client(SendMessageRequest(
                peer=chat,
                message=answer,
                no_webpage=True
            ))
            
            logger.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –∫–∞–ø—á—É: {answer}")
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ—à–µ–Ω–∏–∏ –∫–∞–ø—á–∏: {str(e)}")
            return False

    async def join_chats(self, chat_links: List[str], status_msg) -> Dict:
        results = {
            "success": 0,
            "failed": 0,
            "failed_chats": [],
            "captcha_required": [],
            "captcha_screenshots": [],
            "captcha_solved": [],
            "already_member": 0
        }

        try:
            if not chat_links:
                return {"error": "–°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ –ø—É—Å—Ç"}
                
            if not self.client:
                return {"error": "–ö–ª–∏–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω"}
                
            if not self.client.is_connected():
                logger.info("–ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ Telegram...")
                await self.client.connect()
                
            if not await self.client.is_user_authorized():
                return {"error": "–ö–ª–∏–µ–Ω—Ç –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω"}

            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
            account_info = await self.get_account_info()
            current_subscriptions = account_info['limited_chats']
            max_subscriptions = account_info['limits']['max_limited_chats']
            
            start_time = datetime.now()
            total_channels = len(chat_links)
            self.join_count = 0
            self.current_delay = 10
            last_status_update = datetime.now()
            last_pause_update = datetime.now()
            remaining_channels = total_channels

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–ª–µ–Ω—Å—Ç–≤–æ –≤–æ –≤—Å–µ—Ö –∫–∞–Ω–∞–ª–∞—Ö –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º
            for link in chat_links:
                try:
                    if '/joinchat/' in link or '+' in link:
                        continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
                    username = link.split('/')[-1]
                    try:
                        chat = await self.client.get_entity(username)
                        participant = await self.client.get_participants(chat, limit=1)
                        if participant:
                            results["already_member"] += 1
                    except:
                        continue
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —á–ª–µ–Ω—Å—Ç–≤–∞ –≤ –∫–∞–Ω–∞–ª–µ {link}: {str(e)}")

            async def update_status():
                """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞"""
                try:
                    nonlocal last_status_update, last_pause_update
                    current_time = datetime.now()
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã
                    if (current_time - last_status_update).total_seconds() < 2:
                        return
                        
                    # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–∞—É–∑—ã –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
                    update_pause = (current_time - last_pause_update).total_seconds() >= 5
                    if update_pause:
                        last_pause_update = current_time

                    if status_msg and not getattr(status_msg, 'deleted', False):
                        time_passed = current_time - start_time
                        if results["success"] > 0:
                            time_per_channel = time_passed / results["success"]
                            time_left = time_per_channel * (remaining_channels)
                        else:
                            time_left = timedelta(seconds=total_channels * 60)

                        pause_remaining = max(0, self.current_delay - (current_time - last_status_update).total_seconds())
                        minutes = int(pause_remaining // 60)
                        seconds = int(pause_remaining % 60)
                        
                        status_text = (
                            f"üìä –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–ø–∏—Å–∫–∞:\n\n"
                            f"üìã –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ —Å—Å—ã–ª–æ–∫ –≤ —Ñ–∞–π–ª–µ: {total_channels}\n"
                            f"‚úÖ –í–∞–ª–∏–¥–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ –∫–∞–Ω–∞–ª—ã: {total_channels}\n"
                            f"üë• –£–∂–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –∫–∞–Ω–∞–ª–∞—Ö: {results['already_member']}\n"
                            f"üì± –¢–µ–∫—É—â–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏: {current_subscriptions + results['success']}/{max_subscriptions}\n"
                            f"‚ûï –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {max_subscriptions - (current_subscriptions + results['success'])}\n"
                            f"‚åõÔ∏è –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {str(time_left).split('.')[0]}\n\n"
                            f"üîÑ –ù–∞—á–∏–Ω–∞—é –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª—ã...\n"
                            f"–í—Å—Ç—É–ø–∏–ª - {results['success']}\n"
                            f"–û—Å—Ç–∞–ª–æ—Å—å –≤—Å—Ç—É–ø–∏—Ç—å - {remaining_channels}\n"
                            f"–ü–∞—É–∑–∞ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ - {minutes:02d}:{seconds:02d}"
                        )
                        
                        await self.client.edit_message(status_msg, status_text)
                        last_status_update = current_time
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –≤ update_status: {str(e)}")

            for i, link in enumerate(chat_links, 1):
                try:
                    remaining_channels = total_channels - i
                    await update_status()

                    try:
                        if '/joinchat/' in link or '+' in link:
                            invite_hash = link.split('/')[-1]
                            chat = await self.client(ImportChatInviteRequest(invite_hash))
                        else:
                            username = link.split('/')[-1]
                            chat = await self.client(JoinChannelRequest(username))
                        
                        results["success"] += 1
                        self.join_count += 1
                        logger.info(f"–£—Å–ø–µ—à–Ω–æ –≤—Å—Ç—É–ø–∏–ª –≤ –∫–∞–Ω–∞–ª: {link}")
                        
                        if self.join_count == 1:
                            self.current_delay = 10
                        elif self.join_count == 2:
                            self.current_delay = 60
                        else:
                            self.current_delay = min(600, self.current_delay * 1.1)
                            
                        logger.info(f"–û–∂–∏–¥–∞–Ω–∏–µ {self.current_delay} —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ–º")
                        await update_status()  # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–µ—Ä–µ–¥ –ø–∞—É–∑–æ–π
                        await asyncio.sleep(self.current_delay)
                            
                    except FloodWaitError as e:
                        wait_time = e.seconds
                        logger.error(f"–ù—É–∂–Ω–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å {wait_time} —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π")
                        results["failed_chats"].append({
                            "link": link,
                            "error": f"–ù—É–∂–Ω–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å {wait_time} —Å–µ–∫—É–Ω–¥"
                        })
                        results["failed"] += 1
                        
                        await self.client.edit_message(status_msg,
                            f"‚ö†Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –≤—Å—Ç—É–ø–ª–µ–Ω–∏–π\n\n"
                            f"–ù—É–∂–Ω–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å {wait_time} —Å–µ–∫—É–Ω–¥\n"
                            f"–£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {results['success']} –∫–∞–Ω–∞–ª–æ–≤"
                        )
                        
                        await asyncio.sleep(wait_time)
                        self.current_delay = 10
                        continue
                        
                    except Exception as e:
                        error_str = str(e).lower()
                        if "captcha" in error_str:
                            logger.warning(f"–¢—Ä–µ–±—É–µ—Ç—Å—è –∫–∞–ø—á–∞ –¥–ª—è –∫–∞–Ω–∞–ª–∞: {link}")
                            results["captcha_required"].append(link)
                            results["failed"] += 1
                        else:
                            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–∏ –≤ –∫–∞–Ω–∞–ª {link}: {str(e)}")
                            results["failed_chats"].append({
                                "link": link,
                                "error": str(e)
                            })
                            results["failed"] += 1
                            
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–∞–Ω–∞–ª–∞ {link}: {str(e)}")
                    results["failed"] += 1
                    results["failed_chats"].append({
                        "link": link,
                        "error": str(e)
                    })

            final_status = (
                f"‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞\n\n"
                f"üìä –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
                f"üìã –í—Å–µ–≥–æ —Å—Å—ã–ª–æ–∫: {total_channels}\n"
                f"üë• –£–∂–µ —Å–æ—Å—Ç–æ—è–ª–∏ –≤ –∫–∞–Ω–∞–ª–∞—Ö: {results['already_member']}\n"
                f"‚úÖ –£—Å–ø–µ—à–Ω–æ –≤—Å—Ç—É–ø–∏–ª–∏: {results['success']}\n"
                f"‚ùå –û—à–∏–±–∫–∏: {results['failed']}\n"
                f"‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è –∫–∞–ø—á–∞: {len(results['captcha_required'])}\n"
                f"‚è± –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {str(datetime.now() - start_time).split('.')[0]}"
            )
            
            try:
                if status_msg and not getattr(status_msg, 'deleted', False):
                    await self.client.edit_message(status_msg, final_status)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞: {str(e)}")

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –∫–∞–Ω–∞–ª—ã: {str(e)}")
            return {"error": str(e)}
        finally:
            return results

class TelegramBot:
    def __init__(self):
        self.client = None
        self.api_id = int(os.getenv('API_ID', 0))
        self.api_hash = os.getenv('API_HASH', '')
        self.bot_token = os.getenv('BOT_TOKEN', '')
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
        if not all([self.api_id, self.api_hash, self.bot_token]):
            raise ValueError("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (API_ID, API_HASH, BOT_TOKEN)")
        
        self.session_manager = SessionManager(SESSIONS_DIR)
        self.resource_manager = ResourceManager()
        self.user_states = {}
        self.user_accounts = {}
        self.session_name = 'bot_session'  # –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è —Å–µ—Å—Å–∏–∏ –¥–ª—è –±–æ—Ç–∞
        self.cleanup_task = None

    async def start_client(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏ –∑–∞–ø—É—Å–∫ –∫–ª–∏–µ–Ω—Ç–∞ –±–æ—Ç–∞"""
        try:
            logger.info("–°–æ–∑–¥–∞—é –∫–ª–∏–µ–Ω—Ç –±–æ—Ç–∞...")
            self.client = TelegramClient(self.session_name, self.api_id, self.api_hash)
            
            # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ Telegram
            await self.client.start(bot_token=self.bot_token)
            
            # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
            self.setup_handlers()
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –æ—á–∏—Å—Ç–∫–∏
            self.cleanup_task = asyncio.create_task(self.periodic_cleanup())
            
            logger.info("–ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω")
            return True
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {str(e)}")
            if self.client:
                await self.client.disconnect()
            return False

    async def get_or_create_user_account(self, user_id: int, phone: str = None) -> Optional[UserAccount]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            # –ï—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –ø–∞–º—è—Ç–∏, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –µ–≥–æ
            if user_id in self.user_accounts:
                return self.user_accounts[user_id]
            
            # –ï—Å–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω, –∏—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ñ–∞–π–ª —Å–µ—Å—Å–∏–∏
            if not phone:
                # –ò—â–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã —Å–µ—Å—Å–∏–π
                session_files = [f for f in os.listdir(SESSIONS_DIR) 
                               if f.startswith('user_') and not f.endswith('.lock')]
                for session_file in session_files:
                    try:
                        # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ user_PHONE
                        temp_phone = session_file[5:].split('.')[0].split('_')[0]
                        temp_account = UserAccount(temp_phone, self.api_id, self.api_hash, self.session_manager)
                        if await temp_account.start_client():
                            # –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∞–∫–∫–∞—É–Ω—Ç
                            self.user_accounts[user_id] = temp_account
                            return temp_account
                        await temp_account.disconnect()
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å–µ—Å—Å–∏–∏ {session_file}: {str(e)}")
                return None
            
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∞–∫–∫–∞—É–Ω—Ç —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º
            account = UserAccount(phone, self.api_id, self.api_hash, self.session_manager)
            if await account.start_client():
                self.user_accounts[user_id] = account
                return account
            return None
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏/—Å–æ–∑–¥–∞–Ω–∏–∏ –∞–∫–∫–∞—É–Ω—Ç–∞: {str(e)}")
            return None

    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥"""
        
        @self.client.on(events.NewMessage(pattern='/start'))
        async def start_handler(event):
            """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
            user_id = event.sender_id
            
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–∫–∫–∞—É–Ω—Ç
            account = await self.get_or_create_user_account(user_id)
            
            if account:
                # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–∫–∫–∞—É–Ω—Ç
                account_info = await account.get_account_info()
                if account_info:
                    await event.respond(
                        f"üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º!\n\n"
                        f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {account_info['first_name']}\n"
                        f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: {account_info['phone']}\n"
                        f"üíé –¢–∏–ø –∞–∫–∫–∞—É–Ω—Ç–∞: {account_info['account_type']}\n\n"
                        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —á–∞—Ç–æ–≤:\n"
                        f"üì¢ –ö–∞–Ω–∞–ª—ã: {account_info['channels']}\n"
                        f"üë• –ë–æ–ª—å—à–∏–µ –≥—Ä—É–ø–ø—ã (>200): {account_info['large_groups']}\n"
                        f"üë• –ú–∞–ª—ã–µ –≥—Ä—É–ø–ø—ã (‚â§200): {account_info['small_groups']}\n"
                        f"üë§ –õ–∏—á–Ω—ã–µ —á–∞—Ç—ã: {account_info['private_chats']}\n"
                        f"üì± –í—Å–µ–≥–æ —á–∞—Ç–æ–≤: {account_info['total_chats']}\n\n"
                        f"üìà –õ–∏–º–∏—Ç—ã:\n"
                        f"üìä –ö–∞–Ω–∞–ª—ã + –±–æ–ª—å—à–∏–µ –≥—Ä—É–ø–ø—ã: {account_info['limited_chats']}/{account_info['limits']['max_limited_chats']}\n"
                        f"‚ûï –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {account_info['available_joins']}\n"
                        f"üì• –õ–∏–º–∏—Ç –≤—Å—Ç—É–ø–ª–µ–Ω–∏–π –≤ –¥–µ–Ω—å: {account_info['limits']['joins_per_day']}",
                        buttons=[
                            [Button.text("üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤", resize=True)],
                            [Button.text("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", resize=True)]
                        ]
                    )
                    return
            
            # –ï—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
            await event.respond(
                "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É –≤–∞–º —É–ø—Ä–∞–≤–ª—è—Ç—å –ø–æ–¥–ø–∏—Å–∫–∞–º–∏ –Ω–∞ –∫–∞–Ω–∞–ª—ã Telegram.\n\n"
                "–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã –Ω—É–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç:",
                buttons=[
                    [Button.text("üì± –ü–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç", resize=True)]
                ]
            )

        @self.client.on(events.NewMessage(pattern='üì± –ü–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç'))
        async def connect_account_handler(event):
            """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–∞"""
            sender = event.sender_id
            self.user_states[sender] = {'step': 'waiting_phone'}
            await event.respond(
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ: +7XXXXXXXXXX",
                buttons=[
                    [Button.text("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", resize=True)]
                ]
            )

        @self.client.on(events.NewMessage(pattern=r'^\+\d+$'))
        async def phone_handler(event):
            """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–≤–æ–¥–∞ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
            sender = event.sender_id
            if sender not in self.user_states or self.user_states[sender].get('step') != 'waiting_phone':
                return

            phone = event.text
            try:
                # –°–æ–∑–¥–∞–µ–º –∞–∫–∫–∞—É–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user_account = UserAccount(phone, self.api_id, self.api_hash, self.session_manager)
                self.user_states[sender]['account'] = user_account
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–¥–∞ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª–µ
                status_msg = await event.respond("üîÑ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–µ—Ä–º–∏–Ω–∞–ª –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è...")
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º –∫–ª–∏–µ–Ω—Ç –∏ –ø—Ä–æ—Ö–æ–¥–∏–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é —á–µ—Ä–µ–∑ —Ç–µ—Ä–º–∏–Ω–∞–ª
                if await user_account.start_client():
                    self.user_accounts[sender] = user_account
                    del self.user_states[sender]
                    
                    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
                    account_info = await user_account.get_account_info()
                    if account_info:
                        await status_msg.edit(
                            f"‚úÖ –ê–∫–∫–∞—É–Ω—Ç —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω!\n\n"
                            f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {account_info['first_name']}\n"
                            f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: {account_info['phone']}\n"
                            f"üíé –¢–∏–ø –∞–∫–∫–∞—É–Ω—Ç–∞: {account_info['account_type']}\n"
                            f"üìä –ö–∞–Ω–∞–ª–æ–≤: {account_info['channels_and_large_groups']}/{account_info['limits']['channels_max']}",
                            buttons=[
                                [Button.text("üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤", resize=True)],
                                [Button.text("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", resize=True)]
                            ]
                        )
                    else:
                        raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ")
                else:
                    await status_msg.edit(
                        "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.\n"
                        "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
                        buttons=[
                            [Button.text("üì± –ü–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç", resize=True)]
                        ]
                    )
                    del self.user_states[sender]
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞: {str(e)}")
                await event.respond(
                    "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                    buttons=[
                        [Button.text("üì± –ü–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç", resize=True)]
                    ]
                )
                if sender in self.user_states:
                    del self.user_states[sender]

        @self.client.on(events.NewMessage(pattern='‚ùå –û—Ç–º–µ–Ω–∏—Ç—å'))
        async def cancel_handler(event):
            """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–º–µ–Ω—ã –æ–ø–µ—Ä–∞—Ü–∏–∏"""
            sender = event.sender_id
            if sender in self.user_states:
                if 'account' in self.user_states[sender]:
                    await self.user_states[sender]['account'].disconnect()
                del self.user_states[sender]
            
            await event.respond(
                "‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞",
                buttons=[
                    [Button.text("üì± –ü–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç", resize=True)]
                ]
            )

        @self.client.on(events.NewMessage(pattern='üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤'))
        async def upload_channels_handler(event):
            """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞ –∫–∞–Ω–∞–ª–æ–≤"""
            sender = event.sender_id
            if sender not in self.user_accounts:
                await event.respond(
                    "‚ùå –°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç",
                    buttons=[
                        [Button.text("üì± –ü–æ–¥–∫–ª—é—á–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç", resize=True)]
                    ]
                )
                return

            # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ñ–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º –∫–∞–Ω–∞–ª–æ–≤
            await event.respond(
                "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª —Å–æ —Å–ø–∏—Å–∫–æ–º –∫–∞–Ω–∞–ª–æ–≤ (txt, csv, docx –∏–ª–∏ xlsx).\n"
                "–ö–∞–∂–¥–∞—è —Å—Å—ã–ª–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤ –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–µ.\n"
                "–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ñ–æ—Ä–º–∞—Ç—ã:\n"
                "- t.me/channel\n"
                "- @channel\n"
                "- https://t.me/joinchat/...\n\n"
                "‚ùóÔ∏è –í–Ω–∏–º–∞–Ω–∏–µ: –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∫–∞–Ω–∞–ª—ã –º–æ–≥—É—Ç —Ç—Ä–µ–±–æ–≤–∞—Ç—å —Ä—É—á–Ω–æ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –∫–∞–ø—á–∏. "
                "–í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤–∞–º –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤—Å—Ç—É–ø–∏—Ç—å –≤ —Ç–∞–∫–∏–µ –∫–∞–Ω–∞–ª—ã —á–µ—Ä–µ–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç Telegram.",
                buttons=[
                    [Button.text("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", resize=True)]
                ]
            )
            self.user_states[sender] = {'step': 'waiting_file'}

        @self.client.on(events.NewMessage(func=lambda e: e.file))
        async def process_file_handler(event):
            """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞"""
            sender = event.sender_id
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            if sender not in self.user_states:
                await event.respond("‚ùå –°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤'")
                return
                
            if self.user_states[sender].get('step') != 'waiting_file':
                await event.respond("‚ö†Ô∏è –î–æ–∂–¥–∏—Ç–µ—Å—å –æ–∫–æ–Ω—á–∞–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —Ñ–∞–π–ª–∞")
                return

            try:
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
                self.user_states[sender]['step'] = 'processing_file'
                
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
                status_msg = await event.respond("üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Ñ–∞–π–ª...")

                # –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª
                file = await event.message.download_media(file=BytesIO())
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å—Å—ã–ª–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
                links = await self.process_file(file)
                if not links:
                    await status_msg.edit("‚ùå –í —Ñ–∞–π–ª–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å—Å—ã–ª–æ–∫ –Ω–∞ –∫–∞–Ω–∞–ª—ã")
                    return

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫–∫–∞—É–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                if sender not in self.user_accounts:
                    await status_msg.edit(
                        "‚ùå –°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç",
                        buttons=[
                            [Button.text("üîë –í–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç", resize=True)]
                        ]
                    )
                    return

                user_account = self.user_accounts[sender]
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ —á–∞—Ç—ã
                chat_links = await user_account.extract_chat_links("\n".join(links))
                if not chat_links:
                    await status_msg.edit("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ –∫–∞–Ω–∞–ª—ã")
                    return

                # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫–∫–∞—É–Ω—Ç–µ
                account_info = await user_account.get_account_info()
                current_subscriptions = account_info['limited_chats']
                max_subscriptions = account_info['limits']['max_limited_chats']
                available_joins = max_subscriptions - current_subscriptions

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–ª–µ–Ω—Å—Ç–≤–æ –≤ –∫–∞–Ω–∞–ª–∞—Ö
                already_member_count = 0
                await status_msg.edit("üîÑ –ü—Ä–æ–≤–µ—Ä—è—é —á–ª–µ–Ω—Å—Ç–≤–æ –≤ –∫–∞–Ω–∞–ª–∞—Ö...")
                
                for link in chat_links:
                    try:
                        if '/joinchat/' in link or '+' in link:
                            continue
                        username = link.split('/')[-1]
                        try:
                            chat = await user_account.client.get_entity(username)
                            participant = await user_account.client.get_participants(chat, limit=1)
                            if participant:
                                already_member_count += 1
                        except:
                            continue
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —á–ª–µ–Ω—Å—Ç–≤–∞ –≤ –∫–∞–Ω–∞–ª–µ {link}: {str(e)}")
                
                # –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è (60 —Å–µ–∫—É–Ω–¥ –Ω–∞ –∫–∞–Ω–∞–ª)
                channels_to_join = len(chat_links) - already_member_count
                estimated_time = channels_to_join * 60
                hours = estimated_time // 3600
                minutes = (estimated_time % 3600) // 60
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∞–Ω–∞–ª–∏–∑–µ
                await status_msg.edit(
                    f"üìä –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–ø–∏—Å–∫–∞:\n\n"
                    f"üìã –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ —Å—Å—ã–ª–æ–∫ –≤ —Ñ–∞–π–ª–µ: {len(chat_links)}\n"
                    f"‚úÖ –í–∞–ª–∏–¥–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –Ω–∞ –∫–∞–Ω–∞–ª—ã: {len(chat_links)}\n"
                    f"üë• –£–∂–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –≤ –∫–∞–Ω–∞–ª–∞—Ö: {already_member_count}\n"
                    f"üì± –¢–µ–∫—É—â–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏: {current_subscriptions}/{max_subscriptions}\n"
                    f"‚ûï –î–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: {available_joins}\n"
                    f"‚åõÔ∏è –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: {hours}—á {minutes}–º–∏–Ω\n\n"
                    f"üîÑ –ù–∞—á–∏–Ω–∞—é –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ –≤ –∫–∞–Ω–∞–ª—ã...\n"
                    f"–í—Å—Ç—É–ø–∏–ª - {already_member_count}\n"
                    f"–û—Å—Ç–∞–ª–æ—Å—å –≤—Å—Ç—É–ø–∏—Ç—å - {len(chat_links) - already_member_count}\n"
                    f"–ü–∞—É–∑–∞ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ - 00:00"
                )

                # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –∫–∞–Ω–∞–ª—ã
                results = await user_account.join_chats(chat_links, status_msg)
                
                if "error" in results:
                    await status_msg.edit(f"‚ùå –û—à–∏–±–∫–∞: {results['error']}")
                    return

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∫—Ä–∏–Ω—à–æ—Ç—ã –∫–∞–ø—á–∏, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
                if results.get('captcha_screenshots'):
                    await event.respond("üì∏ –°–∫—Ä–∏–Ω—à–æ—Ç—ã —Å–æ–æ–±—â–µ–Ω–∏–π —Å –∫–∞–ø—á–µ–π:")
                    for screenshot_info in results['captcha_screenshots']:
                        caption = f"–ö–∞–ø—á–∞ –¥–ª—è –∫–∞–Ω–∞–ª–∞: {screenshot_info['link']}"
                        try:
                            await self.client.send_file(
                                event.chat_id,
                                screenshot_info['screenshot'],
                                caption=caption
                            )
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞: {str(e)}")
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏
                await event.respond(
                    "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                    buttons=[
                        [Button.text("üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤", resize=True)],
                        [Button.text("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", resize=True)]
                    ]
                )
            
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {str(e)}")
                await event.respond(
                    f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {str(e)}",
                    buttons=[
                        [Button.text("üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤", resize=True)]
                    ]
                )
            finally:
                # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                if sender in self.user_states:
                    del self.user_states[sender]

    async def process_file(self, file: BytesIO) -> List[str]:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Å—ã–ª–æ–∫"""
        links = []
        seen = set()
        
        try:
            # –ü—Ä–æ–±—É–µ–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å –∫–∞–∫ Excel
            try:
                import pandas as pd
                df = pd.read_excel(file)
                
                for column in df.columns:
                    for value in df[column].dropna():
                        value = str(value).strip()
                        if value:
                            logger.info(f"–ù–∞–π–¥–µ–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ Excel: {value}")
                            if value.startswith(('https://t.me/', 'http://t.me/', '@', 't.me/')):
                                links.append(value)
                                logger.info(f"–î–æ–±–∞–≤–ª–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –∏–∑ Excel: {value}")
                                
            except Exception as excel_e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ Excel: {str(excel_e)}")
                
            # –ï—Å–ª–∏ Excel –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
            if not links:
                logger.info("–ü—Ä–æ–±—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã...")
                file.seek(0)
                
                # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏
                encodings = ['utf-8', 'windows-1251', 'cp1251']
                
                for encoding in encodings:
                    try:
                        # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as temp:
                            temp.write(file.read())
                            temp_path = temp.name
                            
                        # –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª —Å —Ç–µ–∫—É—â–µ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
                        with open(temp_path, 'r', encoding=encoding) as f:
                            content = f.read()
                            # –ò—â–µ–º –≤—Å–µ —Å—Å—ã–ª–∫–∏ –≤ —Ç–µ–∫—Å—Ç–µ
                            tg_links = re.findall(r'(?:https?://)?(?:t\.me|telegram\.me)/[a-zA-Z0-9_@/+-]+', content)
                            username_links = re.findall(r'@[a-zA-Z][a-zA-Z0-9_]{3,}(?:\s|$)', content)
                            
                            for link in tg_links:
                                if link not in links:
                                    logger.info(f"–ù–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –≤ —Ç–µ–∫—Å—Ç–µ: {link}")
                                    links.append(link)
                            
                            for username in username_links:
                                username = username.strip()
                                if username not in links:
                                    logger.info(f"–ù–∞–π–¥–µ–Ω —é–∑–µ—Ä–Ω–µ–π–º: {username}")
                                    links.append(username)
                                    
                        # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                        os.unlink(temp_path)
                        break  # –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ—á–∏—Ç–∞–ª–∏ —Ñ–∞–π–ª, –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞
                        
                    except Exception as text_e:
                        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π {encoding}: {str(text_e)}")
                        continue
                        
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {str(e)}")
            return []
            
        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º —Å—Å—ã–ª–∫–∏
        normalized_links = []
        for link in links:
            # –£–±–∏—Ä–∞–µ–º @ –¥–ª—è —é–∑–µ—Ä–Ω–µ–π–º–æ–≤
            if link.startswith('@'):
                link = link[1:]
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å—Å—ã–ª–∫–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å http:// –∏–ª–∏ https://
            if not link.startswith(('http://', 'https://')):
                link = f"https://t.me/{link}"
            
            if link not in seen:
                seen.add(link)
                normalized_links.append(link)
                logger.info(f"–ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–∞ —Å—Å—ã–ª–∫–∞: {link}")
                
        return normalized_links

    async def periodic_cleanup(self):
        """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤"""
        while True:
            try:
                self.resource_manager.cleanup_old_files(SCREENSHOTS_DIR)
                self.resource_manager.cleanup_old_files(SESSIONS_DIR)
                await asyncio.sleep(3600)  # –û—á–∏—Å—Ç–∫–∞ –∫–∞–∂–¥—ã–π —á–∞—Å
            except asyncio.CancelledError:
                break
        except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –æ—á–∏—Å—Ç–∫–∏: {str(e)}")
                await asyncio.sleep(60)

    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–∞–±–æ—Ç—ã"""
        try:
            # –û—Ç–º–µ–Ω—è–µ–º –∑–∞–¥–∞—á—É –æ—á–∏—Å—Ç–∫–∏
            if self.cleanup_task and not self.cleanup_task.done():
                self.cleanup_task.cancel()
                try:
                    await self.cleanup_task
                except asyncio.CancelledError:
                    pass

            # –û—Ç–∫–ª—é—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            for user_id, user_account in list(self.user_accounts.items()):
                try:
                    await user_account.disconnect()
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {str(e)}")
                finally:
                    self.user_accounts.pop(user_id, None)
            
            # –û—Ç–∫–ª—é—á–∞–µ–º –±–æ—Ç–∞
            if self.client:
                try:
                    await self.client.disconnect()
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –±–æ—Ç–∞: {str(e)}")
                finally:
                    self.client = None
            
            # –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
            try:
                self.session_manager.release_lock(self.session_name)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: {str(e)}")
            
            # –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
            try:
                self.resource_manager.cleanup_old_files(SCREENSHOTS_DIR, max_age_hours=1)
                self.resource_manager.cleanup_old_files(SESSIONS_DIR, max_age_hours=1)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤: {str(e)}")
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Ä–µ—Å—É—Ä—Å–æ–≤: {str(e)}")
        finally:
            # –û—á–∏—â–∞–µ–º –≤—Å–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            self.user_states.clear()
            self.user_accounts.clear()

    async def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è"""
        try:
            logger.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")
            if not await self.start_client():
                logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞")
                return
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
            await self.client.run_until_disconnected()
                    
        except KeyboardInterrupt:
            logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
        except Exception as e:
            logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
        finally:
            await self.cleanup()
            logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    async def test_links(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Å—ã–ª–æ–∫"""
        test_links = [
            "https://t.me/otzivi_wb_ozon",
            "https://t.me/cargogood1",
            "https://t.me/kanalv2025",
            "https://t.me/wildberries_t0prf",
            "https://t.me/biznesdvigmoskva",
            "https://t.me/in4at",
            "https://t.me/site77777",
            "https://t.me/parisinfoexpress",
            "https://t.me/globalotzivi",
            "https://t.me/biznesuae",
            "https://t.me/halyava_na_wb_ozon",
            "https://t.me/vopros_ysmp"
        ]
        
        links = await self.extract_chat_links("\n".join(test_links))
        logger.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Å—ã–ª–æ–∫:")
        for link in links:
            logger.info(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞ —Å—Å—ã–ª–∫–∞: {link}")
        return links

if __name__ == "__main__":
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
        for directory in [LOGS_DIR, SESSIONS_DIR, SCREENSHOTS_DIR]:
            if not os.path.exists(directory):
                os.makedirs(directory, exist_ok=True)
                logger.info(f"–°–æ–∑–¥–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {directory}")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
        bot = TelegramBot()
        asyncio.run(bot.run())
    except KeyboardInterrupt:
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
        sys.exit(1)

